""""""
def _print_lock_warning(package_locks):
    print("""

For faster builds put these into the debian_package_index rule

package_lock = {{
{}
}}

""".format(",\n".join(package_locks)))



def _set_struct_with_parents(struct, value = None, keys = []):
    klen = len(keys)
    for i in range(klen - 1):
        k = keys[i]
        if not k in struct:
            struct[k] = {}
        struct = struct[k]
     
    struct[keys[-1]] = value
     

def _parse_depends(depends_raw):
    depends = {}

    for d in depends_raw.split(", "):
        s = d.split(" (", 1)
        if len(s) == 1:
            depends[s[0]] = ""
        else:
            # TODO: support version ranges
            depends[s[0]] = s[1].rstrip(")").lstrip(">=").lstrip(" ")
    return depends

def _clear(str):
    return  str.replace("~", "_t_").replace("+", "_p_").replace(":", "_c_").replace("-", "_u_").replace(".", "_d_")

_DEB_IMPORT_TMPL='''\
    http_archive(
        name = "{dist}_{arch}_{name}_{version}",
        urls = {urls},
        sha256 = "{sha256}",
        build_file_content = """
exports_files(["data.tar.xz"])
"""
    )
'''

def _resolve_transitive_closure(transitive_closure, packages, dist, architecture, package, version):
   iteration_max = 9999999
   stack=[(package, version)]
   for i in range(0, iteration_max + 1):
        if not len(stack):
            break
        if i == iteration_max:
            fail("_resolve_transitive_closure exhausted the iteration")
        (package, version) = stack.pop()    

        versions = packages[dist][architecture][package]

        if version == "":
            version = versions.keys()[0]
        elif not version in versions:
            # print("package {} requested version {} but not found, selecting {}".format(package, version, versions.keys()[0]))
            version = versions.keys()[0]
            # TODO: version range
            
        pkg = versions[version]
        key = "{}/{}".format(package, version)
        if key in transitive_closure:
            continue
      

        transitive_closure[key] = (pkg)
        if "Depends" in pkg:
            stack.extend(pkg["Depends"].items())


def _debian_package_index_impl(rctx):
    package_lock = rctx.attr.package_lock

    package_locks = []

    for architecture in rctx.attr.architectures:
        for dist in rctx.attr.dists:
            urls = [
                "{}/debian/dists/{}/main/binary-{}/Packages.xz".format(mirror, dist, architecture)
                for mirror in rctx.attr.mirrors
            ]  
            content_key = "{}/{}".format(dist, architecture)
            output = "{}/Packages.xz".format(content_key)
            r = rctx.download(
                url = urls,
                output = output,
                integrity = package_lock[content_key] if content_key in package_lock else ""
            )
            package_locks.append('    "{}":"{}"'.format(content_key, r.integrity))
            rctx.execute([
                "xz",
                "--decompress",
                output
            ])

    if len(package_lock.keys()) == 0:
        _print_lock_warning(package_locks)
    

    packages = {}

    for architecture in rctx.attr.architectures:
        for dist in rctx.attr.dists:
            packages_path = "{}/{}/Packages".format(dist, architecture)
            contents = rctx.read(packages_path)

            last_key = ""
            pkg = {}

            for group in contents.split("\n\n"):

                for line in group.splitlines(): 

                    if line[0] == " ":
                        pkg[last_key]+="\n" + line
                        continue

                    (key, value) = line.split(": ", 1)
                    if not last_key and len(pkg) == 0 and key != "Package":
                        fail("do not expect this. fix it.")

                    if key == "Depends":
                        value = _parse_depends(value)

                    last_key = key
                    pkg[key] = value
        

                if len(pkg.keys()) != 0:
                    _set_struct_with_parents(
                        packages,
                        value = pkg,
                        keys = [dist, architecture, pkg["Package"], pkg["Version"]]
                    )
                    last_key = ""
                    pkg = {}


    
    
    package_defs=[
        '"""Generated by experimental/apt"""',
        """load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")""",
        "",
        """def packages():"""
    ]
    
    closures = []

    for dist in rctx.attr.dists:
        for architecture in rctx.attr.architectures:
            closure = {}
            for (package, version) in rctx.attr.packages.items():
                _resolve_transitive_closure(
                    closure, packages, dist, architecture, package, version
                )
                closures.append((
                    dist, architecture,
                    package, version, closure
                ))

            for package in closure.values():
                urls = [
                    "{}/debian/{}".format(mirror, package["Filename"])
                    for mirror in rctx.attr.mirrors
                ]  
                package_defs.append(
                    _DEB_IMPORT_TMPL.format(
                        dist = dist,
                        arch = architecture,
                        name = _clear(package["Package"]),
                        version = _clear(package["Version"]),
                        urls = urls,
                        sha256 = package["SHA256"],
                    )
                )

    for (dist, architecture, name, version, closure) in closures:
        name = "{dist}_{arch}_{name}_{version}_closure".format(
            dist = dist,
            arch = architecture,
            name = _clear(name),
            version = _clear(version)
        )
        package_defs.append(
            "{name} = {debs}".format(
                name = name,
                debs = [
                    "@{dist}_{arch}_{name}_{version}//:data.tar.xz".format(
                        dist = dist,
                        arch = architecture,
                        name = _clear(dep["Package"]),
                        version = _clear(dep["Version"]),
                    )
                    for dep in closure.values()
                ]
            )
        )


    rctx.file("packages.bzl", "\n".join(package_defs))
    rctx.file("BUILD.bazel", "exports_files(glob(['packages.bzl']))")


debian_package_index = repository_rule(
    implementation = _debian_package_index_impl,
    attrs = {
        "architectures": attr.string_list(),
        "dists": attr.string_list(),
        "mirrors": attr.string_list(
            default = [
                "https://ftp.debian.org"
            ]
        ),
        "packages": attr.string_dict(),
        "package_lock": attr.string_dict()
    }
)
